/*
 * Artefact Download Service API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package service

import (
	"context"
	"errors"
	"fmt"
	"net/http"

	"github.com/codejago/polypully/downloader/api/generated/openapi"
	apperrors "github.com/codejago/polypully/downloader/internal/app/errors"
	http_downloads "github.com/codejago/polypully/downloader/internal/app/http"
)

// DownloaderApiService is a service that implements the logic for the DefaultApiServicer
// This service should implement the business logic for every endpoint for the DefaultApi API.
// Include any external packages or services that will be required by this service.
type DownloaderApiService struct {
	downloads map[string]http_downloads.Download
}

// NewApiService creates a downloader api service
func NewApiService() openapi.DefaultApiServicer {
	return &DownloaderApiService{
		downloads: make(map[string]http_downloads.Download),
	}
}

// DownloadsDownloadIdGet - Get the current status of a download
func (s *DownloaderApiService) DownloadsDownloadIdGet(ctx context.Context, downloadId string) (openapi.ImplResponse, error) {
	download, exists := s.downloads[downloadId]
	if !exists {
		return openapi.Response(http.StatusNotFound, nil), nil
	}
	return openapi.Response(http.StatusOK, openapi.DownloadStatus{
		DownloadId: download.Id,
		Url:        download.Uri,
		Status:     fmt.Sprintf("%d", download.Status),
	}), nil
}

// DownloadsDownloadIdPatch - Update a download
func (s *DownloaderApiService) DownloadsDownloadIdPatch(ctx context.Context, downloadId string, downloadUpdate openapi.DownloadUpdate) (openapi.ImplResponse, error) {
	return openapi.Response(http.StatusNotImplemented, nil), errors.New("DownloadsDownloadIdPatch method not implemented")
}

// DownloadsGet - List all ongoing downloads
func (s *DownloaderApiService) DownloadsGet(ctx context.Context) (openapi.ImplResponse, error) {
	var statuses []openapi.DownloadStatus
	for _, download := range s.downloads {
		if download.Status == http_downloads.DownloadRunning {
			statuses = append(statuses, openapi.DownloadStatus{
				DownloadId: download.Id,
				Url:        download.Uri,
				Status:     fmt.Sprintf("%d", download.Status),
			})
		}
	}
	if len(statuses) == 0 {
		return openapi.Response(http.StatusNotFound, statuses), nil
	}
	return openapi.Response(http.StatusOK, statuses), nil
}

// DownloadsPost - Request a new download
func (s *DownloaderApiService) DownloadsPost(ctx context.Context, downloadRequest openapi.DownloadRequest) (openapi.ImplResponse, error) {
	download := http_downloads.NewDownload(downloadRequest.Url)
	err := download.Download()
	if err != nil {
		if e, ok := err.(*apperrors.ValidationError); ok {
			return openapi.Response(http.StatusBadRequest, openapi.Error{
				Message: e.Error(),
			}), nil
		}
		return openapi.Response(http.StatusInternalServerError, nil), errors.New(err.Error())
	}
	s.downloads[download.Id] = download
	return openapi.Response(http.StatusOK, openapi.DownloadStatus{
		DownloadId: download.Id,
		Url:        download.Uri,
		Status:     fmt.Sprintf("%d", download.Status),
	}), nil
}
